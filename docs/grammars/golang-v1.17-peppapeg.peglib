#From: https://github.com/soasme/PeppaPEG/blob/6ed07665ea0b17e3f993359db7c3025f6338b1f9/configs/golang-v1.17.peg

# Peppa PEG -  Ultra lightweight PEG Parser in ANSI C.
#
# MIT License
#
# Copyright (c) 2021 Ju
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# @file       golang-v1.17.peg
# @brief      A complete grammar for golang v1.17
# @author     Ju Lin
# @copyright  MIT
# @date       2021
# @see        https://github.com/soasme/PeppaPEG

SourceFile       <- &. ws* PackageClause eol+ (ImportDecl eol+ ( ImportDecl eol+)*)? ws* (TopLevelDecl eol+ (TopLevelDecl eol+)*)? ws* !.

newline        <- "\n"

#@lifted
~eol            <- (" " / "\t" / block_comment)* (";" / "\n" / line_comment)

#@lifted @squashed
whitespace <- " " / "\t" / "\r" / "\n"

#@lifted @squashed
line_comment <- "//" (!"\n" .)* ("\n" / !.)

#@lifted @squashed
block_comment <- "/*" (!"*/" .)* "*/"

#@lifted
comment <- line_comment / block_comment

#@lifted
~ws <- whitespace / line_comment / block_comment

#@lifted
inlinews <- " " / "\t" / block_comment

#@lifted
~linews <- " " / "\t" / comment

unicode_char   <- !"\x0a" .
unicode_letter <- [A-Za-z] #[\p{L}]
unicode_digit  <- [0-9] #[\p{Nd}]

letter        <- unicode_letter / "_"
decimal_digit <- [0-9]
binary_digit  <- [0-1]
octal_digit   <- [0-7]
hex_digit     <- [0-9] / [a-f] / [A-F]

#@lifted
Keywords <- "break" / "default" / "func" / "interface" / "select" /
            "case" / "defer" / "go" / "map" / "struct" /
            "chan" / "else" / "goto" / "package" / "switch" /
            "const" / "fallthrough" / "if" / "range" / "type" /
            "continue" / "for" / "import" / "return" / "var"

#@squashed
identifier <- !(Keywords !(letter/unicode_digit)) <letter (letter / unicode_digit)*>

#@lifted
int_lit        <- (binary_lit / octal_lit / hex_lit / decimal_lit) !("_" / "." / "p")
#@squashed
decimal_lit    <- <"0" / ([1-9] ↑ ("_"? decimal_digits)?)>
#@squashed
binary_lit     <- <"0b"i ↑ "_"? binary_digits>
#@squashed
octal_lit      <- <"0o"i? "_"? octal_digits>
#@squashed
hex_lit        <- <"0x"i ↑ "_"? hex_digits>

#@squashed
decimal_digits <- decimal_digit ("_"? decimal_digit)*
#@squashed
binary_digits  <- binary_digit ("_"? binary_digit)*
#@squashed
octal_digits   <- octal_digit ("_"? octal_digit)*
#@squashed
hex_digits     <- hex_digit ("_"? hex_digit)*

#@lifted
float_lit         <- (decimal_float_lit / hex_float_lit) ↑ !letter

#@squashed
decimal_float_lit <-< decimal_digits "." ↑ decimal_digits? decimal_exponent? /
                    decimal_digits decimal_exponent /
                    "." ↑ decimal_digits decimal_exponent?>
#@squashed
decimal_exponent  <- [Ee] ↑ [+-]? decimal_digits

#@squashed
hex_float_lit     <- <"0x"i hex_mantissa hex_exponent>
#@squashed
hex_mantissa      <- "_"? hex_digits "." ↑ hex_digits? /
                    "_"? hex_digits /
                    "." ↑ hex_digits
#@squashed
hex_exponent      <- [Pp] ↑ [+-]? decimal_digits

#@squashed
imaginary_lit <- (decimal_float_lit / hex_float_lit / binary_lit / octal_lit / hex_lit / decimal_lit / decimal_digits) "i"

#@squashed
rune_lit         <- <"'" ↑ !"'" ( byte_value / unicode_value ) "'">
unicode_value    <- little_u_value / big_u_value / escaped_char / unicode_char
byte_value       <- octal_byte_value / hex_byte_value
octal_byte_value <- "\\" octal_digit{3}

hex_byte_value   <- "\\x" hex_digit{2}

little_u_value   <- "\\u" hex_digit{4}

big_u_value      <- "\\U" hex_digit{8}

escaped_char     <- "\\" ( "a" / "b" / "f" / "n" / "r" / "t" / "v" / "\\" / "'" / "\"")

#@lifted
string_lit             <- raw_string_lit / interpreted_string_lit

#@squashed
raw_string_lit         <- <"`" (!"`" (unicode_char / newline))* "`">

#@squashed
interpreted_string_lit <- <"\"" (!"\"" (unicode_value / byte_value))* "\"">

Type      <- TypeLit / "(" Type ")" / TypeName
#@nonterminal
TypeName  <- QualifiedIdent / identifier
#@lifted
TypeLit   <- ArrayType / SliceType / StructType / PointerType / FunctionType / InterfaceType / MapType / ChannelType

ArrayType   <- "[" ws* ArrayLength ws* "]" inlinews* ElementType
#@lifted
ArrayLength <- Expression
#@lifted
ElementType <- Type

SliceType <- "[" ws* "]" inlinews* ElementType

StructType    <- "struct" linews* "{" ↑ ws* (FieldDecl (eol+ ws* FieldDecl)*)? ws* "}"
FieldDecl     <- (EmbeddedField &eol / IdentifierList linews+ Type / EmbeddedField) (linews* Tag)?
EmbeddedField <- Pointer? inlinews* TypeName
Pointer       <- "*"
Tag           <- string_lit

PointerType <- "*" inlinews* BaseType
#@lifted
BaseType    <- Type

FunctionType   <- "func" linews* Signature
Signature      <- Parameters (inlinews* Result)?

Parameters     <- "(" ↑ (ws* ParameterList linews* ","?)? ws* ")"

ParameterList  <- ParameterDecl (linews* "," ws* ParameterDecl)*
ParameterDecl  <- IdentifierList linews* "..."? linews* Type / "..."? linews* Type

Result         <- Type / Parameters

InterfaceType      <- "interface" linews* "{" ↑ ws* ((InterfaceTypeDecl eol+ ws*)+ / InterfaceTypeDecl)? ws* "}"
InterfaceTypeDecl <- MethodSpec / InterfaceTypeName
MethodSpec         <- MethodName Signature
MethodName         <- identifier
InterfaceTypeName  <- TypeName

MapType     <- "map" "[" KeyType "]" ElementType
KeyType     <- Type

ChannelType <- ("chan" linews* "<-" / "<-" linews* "chan" / "chan" !(letter/unicode_digit)) ↑ linews* ElementType

Block <- "{" ↑ ws* StatementList ws* "}"
StatementList <- (Statement eol+ ( ws* Statement eol+)*)?

Declaration   <- ConstDecl / TypeDecl / VarDecl
TopLevelDecl  <- Declaration / MethodDecl / FunctionDecl

ConstDecl      <- "const" linews+ ↑ ( "(" ↑ ws* (ConstSpec eol+ linews*)* ws* ")" / ConstSpec)
ConstSpec      <- IdentifierList (linews* Type? linews* "=" linews* ExpressionList)?

#@nonterminal
IdentifierList <- identifier (linews* "," ws* identifier)*

#@nonterminal
ExpressionList <- Expression (linews* "," ws* Expression)*

TypeDecl <- "type" linews+ ↑ ( TypeSpec / "(" ws* (TypeSpec eol+ linews*)* ws* ")" )
TypeSpec <- AliasDecl / TypeDef

AliasDecl <- identifier linews* "=" linews* Type

TypeDef <- identifier linews+ Type

VarDecl     <- "var" linews+ ↑ ( "(" ↑ ws* (VarSpec (eol+ ws* VarSpec)*)? ws* ")" / VarSpec)
VarSpec     <- IdentifierList linews* ( Type (linews* "=" ↑ ws* ExpressionList)? / "=" ↑ ws* ExpressionList )

ShortVarDecl <- IdentifierList linews* ":=" ↑ ws* ExpressionList

FunctionDecl <- "func" linews+ FunctionName ↑ linews* Signature (linews* FunctionBody)?
FunctionName <- identifier
#@lifted
FunctionBody <- Block

MethodDecl <- "func" linews* Receiver ↑ linews* MethodName linews* Signature (linews* FunctionBody)?
Receiver   <- "(" ↑ linews* (identifier linews+ Type / Type) linews* ")"

#@lifted
Operand     <- Literal / OperandName / "(" Expression ")"
#@lifted
Literal     <- BasicLit / CompositeLit / FunctionLit
#@lifted
BasicLit    <- imaginary_lit / float_lit / int_lit / rune_lit / string_lit

#@lifted
OperandName <- QualifiedIdent / identifier

QualifiedIdent <- PackageName inlinews* "." ws* identifier

CompositeLit  <- LiteralType LiteralValue
LiteralType   <- StructType / "[" "..." "]" ElementType / ArrayType /
                SliceType / MapType / TypeName
LiteralValue  <- "{" ↑ ws* (ElementList linews* ","? ws*)? ws* "}"
ElementList   <- KeyedElement (ws* "," ws* KeyedElement)*
KeyedElement  <- (Key linews* ":")? ws* Element
Key           <- LiteralValue / Expression / FieldName
FieldName     <- identifier
Element       <- Expression / LiteralValue

FunctionLit <- "func" linews* Signature linews* FunctionBody

#@nonterminal
PrimaryExpr <- (Operand / Conversion / MethodExpr) (Selector / Index / Slice / TypeAssertion / Arguments)*

Selector       <- "." ws* identifier
Index          <- "[" ws* Expression ws* "]"
Slice          <- "[" ws* Expression? ws* ":" ws* Expression? ws* "]" /
                 "[" ws* Expression? ws* ":" ws* Expression ws* ":" ws* Expression ws* "]"
TypeAssertion  <- "." "(" ws* Type ws* ")"
Arguments      <- "(" ↑ ws* (( ExpressionList / Type (linews* "," ws* ExpressionList)? ) linews* "..."? linews* ","? )? ws* ")"

MethodExpr    <- ReceiverType "." MethodName
ReceiverType  <- Type

#@nonterminal
UnambiguousExpression <- !(TypeName LiteralType inlinews* LiteralValue ↑) Expression

#@lifted
Expression <- LogicalOr

#@nonterminal
LogicalOr <- LogicalAnd ( inlinews* "||" ↑ ws* LogicalAnd)*

#@nonterminal
LogicalAnd <- Comparison ( inlinews* "&&" ↑ ws* Comparison)*

#@nonterminal
Comparison <- Addition ( inlinews* rel_op ↑ ws* Addition)*

#@nonterminal
Addition <- Multiplication ( inlinews* (add_op !"=") ↑ ws* Multiplication)*

#@nonterminal
Multiplication <- UnaryExpr ( inlinews* (mul_op !"=") ↑ ws* UnaryExpr)*

#@nonterminal @scoped
UnaryExpr  <- PrimaryExpr / unary_op+ PrimaryExpr

#@nonterminal
#binary_op  <- "||" / "&&" / (add_op !"=") / (mul_op !"=") / rel_op
rel_op     <- "==" / "!=" / "<=" / "<" !("<" / "-") / ">=" / ">" !">"
add_op     <- "+" !"+" / "-" !"-" / "|" !"|" / "^"
mul_op     <- "*" / "/" !("/"/"*") / "%" / "<<" / ">>" / "&^" / "&" !"&"

unary_op   <- "+" / "-" / "!" / "^" / "*" / "&" / "<-"

Conversion <- Type linews* "(" ws* Expression linews* ","? linews* ")"

#@lifted
Statement <-
	IfStmt / ReturnStmt / ForStmt / Declaration / LabeledStmt /
	GoStmt / BreakStmt / ContinueStmt / GotoStmt /
	FallthroughStmt / SwitchStmt / SelectStmt /
	DeferStmt / Block / SimpleStmt

#@lifted
SimpleStmt <- SendStmt / IncDecStmt / Assignment / ShortVarDecl / ExpressionStmt

#EmptyStmt <- &.

LabeledStmt <- Label linews* ":" !"=" (ws* Statement)?
Label       <- identifier

ExpressionStmt <- Expression

SendStmt <- Channel linews* "<-" ws* Expression
Channel  <- Expression

IncDecStmt <- Expression linews* ( "++" / "--" )

Assignment <- ExpressionList linews* assign_op ws* ExpressionList

assign_op <- (add_op / mul_op)? "="

IfStmt <- "if" linews+ ↑ (SimpleStmt linews* ";")? linews* UnambiguousExpression linews* Block (ws* "else" inlinews ↑ ws* ( IfStmt / Block ))?

SwitchStmt <- TypeSwitchStmt / ExprSwitchStmt

ExprSwitchStmt <- "switch" linews+ (SimpleStmt linews* ";"?)? linews* UnambiguousExpression? ↑ linews* "{" (ws* ExprCaseClause)* ws* "}"
ExprCaseClause <- ExprSwitchCase linews* ":" ws* StatementList
ExprSwitchCase <- "case" ws+ ↑ ExpressionList / "default"

TypeSwitchStmt  <- "switch" linews+ (SimpleStmt linews* ";")? linews* TypeSwitchGuard ↑ linews* "{" (ws* TypeCaseClause)* ws* "}"
TypeSwitchGuard <- (identifier linews* ":=")? linews* PrimaryExpr linews* "." linews* "(" linews* "type" linews* ")"
TypeCaseClause  <- TypeSwitchCase linews* ":" ws* StatementList
TypeSwitchCase  <- "case" ws+ ↑ TypeList / "default"
TypeList        <- Type (linews* "," ws* Type)*

ForStmt <- "for" linews+ ↑ (RangeClause / ForClause / Condition)? linews* Block
Condition <- UnambiguousExpression

ForClause <- InitStmt? linews* ";" linews* Condition? linews* ";" linews* PostStmt?
InitStmt <- SimpleStmt
PostStmt <- SimpleStmt

RangeClause <- (ExpressionList linews* "=" / IdentifierList linews* ":=")? linews* "range" linews+ Expression


GoStmt <- "go" linews+ Expression

SelectStmt <- "select" linews* "{" ↑ ws* (CommClause ws*)*  ws* "}"
CommClause <- CommCase linews* ":" ↑ ws* StatementList
CommCase   <- "case" ↑ linews+ (SendStmt / RecvStmt ) / "default"
RecvStmt   <- (ExpressionList linews* "=" / IdentifierList linews* ":=")? linews* RecvExpr
RecvExpr   <- Expression

ReturnStmt <- "return" !(letter/unicode_digit) ↑ (linews+ ExpressionList)?

BreakStmt <- "break" (linews+ Label)? &eol

ContinueStmt <- "continue" (linews+ Label)? &eol

GotoStmt <- "goto" linews+ Label

FallthroughStmt <- "fallthrough"

DeferStmt <- "defer" linews+ Expression

PackageClause  <- "package" ↑ linews+ PackageName
PackageName    <- identifier

ImportDecl       <- "import" linews* ↑ (  "(" ws* (ImportSpec eol+ linews*)* ws* ")" / ImportSpec)
ImportSpec       <- ("." / PackageName)? linews* ImportPath

#@squashed
ImportPath       <- string_lit
