# Copyright (C) 2022 Exaloop Inc. <https://exaloop.io>
# Codon PEG grammar
# Adopted from Python 3's PEG grammar (https://docs.python.org/3/reference/grammar.html)

# TODO: nice docstrs

program <- (statements (_ EOL)* / (_ EOL)*) !.
#fstring <- star_expressions _ (':' format_spec)? _ !.

# Macros
list(c, e)  <- e (_ c _ e)*
tlist(c, e) <- e (_ c _ e)* (_ <c>)?

statements <- ((_ EOL)* statement)+
statement <- SAMEDENT (compound_stmt / simple_stmt)
simple_stmt <- tlist(';', small_stmt) _ EOL
small_stmt <-
    assignment
  / 'pass' &(SPACE / ';' / EOL)
  / 'break' &(SPACE / ';' / EOL)
  / 'continue' &(SPACE / ';' / EOL)
  / global_stmt
  / nonlocal_stmt
  / yield_stmt &(SPACE / ';' / EOL)
  / assert_stmt
  / del_stmt
  / return_stmt &(SPACE / ';' / EOL)
  / raise_stmt &(SPACE / ';' / EOL)
  / print_stmt
  / import_stmt
  / expressions &(_ ';' / _ EOL)
  / custom_small_stmt

assignment <-
    id _ ':' _ expression (_ '=' _ star_expressions)?
  / (star_targets _ (!'==' '=') _)+ star_expressions !(_ '=')
  / star_expression _ augassign '=' ^ _ star_expressions
augassign <- <
  '+' / '-' / '**' / '*' / '@' / '//' / '/' / '%' / '&' / '|' / '^' / '<<' / '>>'
>
global_stmt <- 'global' SPACE tlist(',', NAME)
nonlocal_stmt <- 'nonlocal' SPACE tlist(',', NAME)
yield_stmt <-
    'yield' SPACE 'from' SPACE expression
  / 'yield' (SPACE expressions)?
assert_stmt <- 'assert' SPACE expression (_ ',' _ expression)?
# TODO: do targets as in Python
del_stmt <- 'del' SPACE tlist(',', expression)
return_stmt <- 'return' (SPACE expressions)?
# TODO: raise expression 'from' expression
raise_stmt <- 'raise' (SPACE expression)?
print_stmt <-
  'print' SPACE star_expression (_ ',' _ star_expression)* (_ <','>)?
  / 'print' _ &EOL
import_stmt <- import_name / import_from
import_name <- 'import' SPACE list(',', as_name)
as_name <- dot_name (SPACE 'as' SPACE NAME)?
import_from <-
  'from' SPACE (_ <'.'>)* (_ dot_name)? SPACE 'import' SPACE '*'
  / 'from' SPACE (_ <'.'>)* (_ dot_name)? SPACE 'import' SPACE
    (from_as_parens / from_as_items)
from_as_parens <- '(' _ tlist(',', from_as) _ ')'
from_as_items <- list(',', from_as)
from_as <- from_id (SPACE 'as' SPACE NAME)?
from_id <-
  dot_name _ ':' _ expression
  / dot_name _ from_params (_ '->' _ expression)?
  / dot_name
dot_name <- id (_ '.' _ NAME)*
from_params <- '(' _ tlist(',', from_param)? _ ')'
from_param <- expression
#TODO expand import logic / param

suite <- (simple_stmt / (_ EOL)+ &INDENT statements (_ EOL)* &DEDENT)
compound_stmt <-
    function
  / if_stmt
  / class
  / with_stmt
  / for
  / try_stmt
  / while_stmt
  / match_stmt
  / custom_stmt

if_stmt <- ('if' SPACE named_expression _ ':' _ suite)
           (SAMEDENT 'elif' SPACE named_expression _ ':' _ suite)*
           (SAMEDENT 'else' _ ':' _ suite)?
while_stmt <- ('while' SPACE named_expression _ ':' _ suite)
              (SAMEDENT 'else' (SPACE 'not' SPACE 'break')*  _ ':' _ suite)?
for <- decorator? for_stmt
for_stmt <- ('for' SPACE star_targets)
            (SPACE 'in' SPACE star_expressions _ ':' _ suite)
            (SAMEDENT 'else' (SPACE 'not' SPACE 'break')* _ ':' _ suite)?
with_stmt <- 'with' SPACE (with_parens_item / with_item) _ ':' _ suite
with_parens_item <- '(' _ tlist(',', as_item) _ ')'
with_item <- list(',', as_item)
as_item <-
    expression SPACE 'as' SPACE id &(_ (',' / ')' / ':'))
  / expression
# TODO: else block?
try_stmt <-
    ('try' _ ':' _ suite)
    excepts
    (SAMEDENT 'finally' _ ':' _ suite)?
  / ('try' _ ':' _ suite) (SAMEDENT 'finally' _ ':' _ suite)?
excepts <- (SAMEDENT except_block)+
except_block <-
    'except' SPACE expression (SPACE 'as' SPACE NAME)? _ ':' _ suite
  / 'except' _ ':' _ suite
function <-
  extern_decorators function_def (_ EOL)+ &INDENT extern (_ EOL)* &DEDENT
  / decorators? function_def _ suite
extern <- (empty_line* EXTERNDENT (!EOL .)* EOL empty_line*)+
~empty_line <- [ \t]* EOL
function_def <-
    'def' SPACE NAME _ generics _ params (_ '->' _ expression)? _ ':'
  / 'def' SPACE NAME _ params (_ '->' _ expression)? _ ':'
params <- '(' _ tlist(',', param)? _ ')'
param <-
    param_name _ ':' _ expression (_ '=' _ expression)?
  / param_name (_ '=' _ expression)?
param_name <- <'**' / '*'>? _ NAME
generics <- '[' _ tlist(',', param) _ ']'
decorators <- decorator+
decorator <- ('@' _ !(('llvm' / 'python') _ EOL) named_expression _ EOL SAMEDENT)
extern_decorators <-
  decorators? ('@' _ <'llvm'/'python'> _ EOL SAMEDENT) decorators?
class <- decorators? class_def
base_class_args <- '(' _ tlist(',', expression)? _ ')'
class_args <-
  generics _ base_class_args
  / generics
  / base_class_args
class_def <- 'class' SPACE NAME _ class_args? _ ':' _ suite
match_stmt <- 'match' SPACE expression _ ':' (_ EOL)+
              &INDENT (SAMEDENT case)+ (_ EOL)* &DEDENT
case <-
  'case' SPACE expression SPACE 'if' SPACE pipe _ ':' _ suite
  / 'case' SPACE expression _ ':' _ suite
custom_stmt <-
  NAME SPACE expression _ ':' _ suite
  / NAME _ ':' _ suite #custom_stmt__PREDICATE

custom_small_stmt <- NAME SPACE expressions #custom_small_stmt__PREDICATE


########################################################################################
# (2) Expressions
########################################################################################

expressions <- tlist(',', expression)
expression <-
  lambdef
  / disjunction SPACE 'if' SPACE disjunction SPACE 'else' SPACE expression
  / pipe
# TODO: make it more pythonic
lambdef <-
  'lambda' SPACE list(',', NAME) _ ':' _ expression
  / 'lambda' _ ':' _ expression
pipe <-
  disjunction (_ <'|>' / '||>'> _ disjunction)+
  / disjunction
disjunction <-
  conjunction (SPACE 'or' SPACE conjunction)+
  / conjunction
conjunction <-
  inversion (SPACE 'and' SPACE inversion)+
  / inversion
inversion <-
  'not' SPACE inversion
  / comparison
comparison <- bitwise_or compare_op_bitwise_or*
compare_op_bitwise_or <-
  SPACE (
      'not' SPACE 'in' SPACE bitwise_or
    / 'is' SPACE 'not' SPACE bitwise_or
    / <'in' / 'is'> SPACE bitwise_or
    )
  / _ <'==' / '!=' / '<=' / '<' / '>=' / '>'> _ bitwise_or
bitwise_or  <- bitwise_xor (_ <'|'> _ bitwise_xor)*
bitwise_xor <- bitwise_and (_ <'^'> _ bitwise_and)*
bitwise_and <- shift_expr  (_ <'&'> _ shift_expr )*
shift_expr <- sum  (_ <'<<' / '>>'> _ sum )*
sum        <- term (_ <'+' / '-'>   _ term)*
term <- factor (_ <'*' / '//' / '/' / '%' / '@'> _ factor)*
factor <-
  <'+' / '-' / '~'> _ factor
  / power
power <-
  primary _ <'**'> _ factor
  / primary
primary <- atom (_ &[([.] primary_tail)*
primary_tail <-
  '.' _ NAME
  / genexp
  / arguments
  / slices
slices <- '[' _ tlist(',', slice) _ ']'
slice <-
  slice_part _ ':' _ slice_part (_ ':' _ slice_part)?
  / expression
slice_part <- expression?
atom <-
  &["'_A-Za-z] (STRING (SPACE STRING)*
  / id
  / 'True'
  / 'False'
  / 'None')
  / &[0-9] (
      INT _ '...' _ INT
    / FLOAT NAME?
    / INT NAME?
    )
  / parentheses
  / '...'
parentheses <- (
  tuple / yield / named / genexp / listexpr / listcomp / dict / set / dictcomp / setcomp
)
tuple <-
  '(' _ ')'
  / '(' _ tlist(',', star_named_expression) _ ')'
yield <- '(' _ 'yield' _ ')'
named <- '(' _ named_expression _ ')'
genexp <- '(' _ named_expression SPACE for_if_clauses _ ')'
listexpr <- '[' _ tlist(',', star_named_expression)? _ ']'
listcomp <- '[' _ named_expression SPACE for_if_clauses _ ']'
set <- '{' _ tlist(',', star_named_expression) _ '}'
setcomp <- '{' _ named_expression SPACE for_if_clauses _ '}'
dict <- '{' _ tlist(',', double_starred_kvpair)? _ '}'
dictcomp <- '{' _ kvpair SPACE for_if_clauses _ '}'
double_starred_kvpair <-
  '**' _ bitwise_or
  / kvpair
kvpair <- expression _ ':' _ expression
for_if_clauses <- for_if_clause (SPACE for_if_clause)*
for_if_clause <- 'for' SPACE star_targets SPACE 'in' SPACE disjunction
                 (SPACE 'if' SPACE disjunction)*

star_targets <- tlist(',', star_target)
star_target <-
  '*' _ !'*' star_target
  / star_parens
  / primary
star_parens <-
  '(' _ tlist(',', star_target) _ ')'
  / '[' _ tlist(',', star_target) _ ']'

star_expressions <- tlist(',', star_expression)
star_expression <-
  '*' _ bitwise_or
  / expression
star_named_expression <-
  '*' _ bitwise_or
  / named_expression
named_expression <-
  / NAME _ ':=' _ ^ expression
  / expression !(_ ':=')
arguments <- '(' _ tlist(',', args)? _ ')'
args <- (simple_args (_ ',' _ kwargs)? / kwargs)
simple_args <- list(',', (starred_expression / named_expression !(_ '=')))
starred_expression <- '*' _ expression
kwargs <-
  list(',', kwarg_or_starred) _ ',' _ list(',', kwarg_or_double_starred)
  / list(',', kwarg_or_starred)
  / list(',', kwarg_or_double_starred)
kwarg_or_starred <-
  NAME _ '=' _ expression
  / starred_expression
kwarg_or_double_starred <-
  NAME _ '=' _ expression
  / '**' _ expression
id <- NAME
INT <- (BININT / HEXINT / DECINT)
BININT <- <'0' [bB] [0-1] ('_'* [0-1])*>
HEXINT <- <'0' [xX] [0-9a-fA-F] ('_'? [0-9a-fA-F])*>
DECINT <- <[0-9] ('_'? [0-9])*>
FLOAT <- (EXPFLOAT / PTFLOAT)
PTFLOAT <- DECINT? '.' DECINT / DECINT '.'
EXPFLOAT <- (PTFLOAT / DECINT) [eE] <'+' / '-'>? DECINT
NAME <-
  #keyword [a-zA-Z_0-9]+ /
  !keyword <[a-zA-Z_] [a-zA-Z_0-9]*>
STRING <- <NAME? STR> #STRING__PREDICATE
STR <- <
  '"""' (!'"""' CHAR)*       '"""'   /  '\'\'\'' (!'\'\'\'' CHAR)*     '\'\'\'' /
  '"'   (!('"' / EOL) CHAR)* '"'     /  '\''     (!('\'' / EOL) CHAR)* '\''
>
CHAR <- ('\\' . / .)
~COMMENT <- <'#' (!EOL .)*>
#~INDENT__NOPACKRAT <- <[ \t]*> INDENT__PREDICATE
#~SAMEDENT__NOPACKRAT <- <[ \t]*> SAMEDENT__PREDICATE
#~DEDENT__NOPACKRAT <- <[ \t]*> DEDENT__PREDICATE
#~EXTERNDENT__NOPACKRAT <- <[ \t]*> EXTERNDENT__PREDICATE
~EOL <- <[\r][\n] / [\r\n]>
~SPACE <- ([ \t]+ / COMMENT / NLP EOL) SPACE?
NLP <- '\\'
~_ <- SPACE?

# TODO: add async / await
~keyword <- <(
  'False' | 'else' | 'import' | 'pass' | 'None' | 'break' | 'except' | 'in' | 'raise' |
  'True' | 'class' | 'finally' | 'is' | 'return' | 'and' | 'continue' | 'for' | 'as'  |
  'lambda' | 'try' | 'def' | 'from' | 'while' | 'assert' | 'del' | 'global' | 'not' |
  'with' | 'elif' | 'if' | 'or' | 'yield'
) ![a-zA-Z_]>

# https://docs.python.org/3/library/string.html#formatspec
#format_spec <- ([<>=^] / [^{}] [<>=^])? [+-]? 'z'? '#'? '0'? [0-9]* [_,]* ('.' [0-9]+)? [bcdeEfFgGnosxX%]?

~EXTERNDENT <- <[ \t]*>
~DEDENT <- <[ \t]*>
~INDENT <- <[ \t]*>
~SAMEDENT <- <[ \t]*>

