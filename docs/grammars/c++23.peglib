#From: https://mingodad.github.io/cpp-grammars/c++23.ebnf.xhtml
#From: https://github.com/cplusplus/draft/
# pegdebug c++23.peglib test.c-bug test.c-bug.html

cplusplus <-
	(&'#' preprocessing_file)? translation_unit

#== lex.tex

n_char <-
     [^}\n] #"{any member of the translation character set except the \unicode{007d}{right curly bracket} or new_line character}"

n_char_sequence <-
    n_char+

named_universal_character <-
    "\\N{" n_char_sequence "}"

hex_quad <-
    hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit

simple_hexadecimal_digit_sequence <-
    hexadecimal_digit+

universal_character_name <-
    "\\u" hex_quad
  / "\\U" hex_quad hex_quad
  / "\\u{" simple_hexadecimal_digit_sequence "}"
  / named_universal_character

preprocessing_token <-
    header_name
  / "import"
  / "module"
  / "export"
  / identifier
  / pp_number
  / character_literal
  / user_defined_character_literal
  / string_literal
  / user_defined_string_literal
  / preprocessing_op_or_punc
  / "{each non_whitespace character that cannot be one of the above}"

#token <-
#    identifier
#  / keyword
#  / literal
#  / operator_or_punctuator

header_name <-
    "<" h_char_sequence ">"
  / '"' q_char_sequence '"'

h_char_sequence <-
    h_char+

h_char <-
    [^>\n] #"{any member of the translation character set except new_line and \unicode{003e}{greater_than sign}}"

q_char_sequence <-
    q_char+

q_char <-
    [^"\n"] #"{any member of the translation character set except new_line and \unicode{0022}{quotation mark}}"

pp_number <-
    (digit / "." digit) (identifier_continue / "'" digit / "'" nondigit / [EePp] sign / ".")*
  #  digit
  #/ "." digit
  #/ pp_number identifier_continue
  #/ pp_number "'" digit
  #/ pp_number "'" nondigit
  #/ pp_number [EePp] sign
  #/ pp_number "."

identifier <-
    !keyword <identifier_start identifier_continue*>

identifier_start <-
    nondigit
  #/ "{an element of the translation character set with the Unicode property XID_Start}"

identifier_continue <-
    digit
  / nondigit
  #/ "{an element of the translation character set with the Unicode property XID_Continue}"

nondigit <-
  [A-Za-z_]
  #  "a" / "b" / "c" / "d" / "e" / "f" / "g" / "h" / "i" / "j" / "k" / "l" / "m"
  #/ "n" / "o" / "p" / "q" / "r" / "s" / "t" / "u" / "v" / "w" / "x" / "y" / "z"
  #/ "A" / "B" / "C" / "D" / "E" / "F" / "G" / "H" / "I" / "J" / "K" / "L" / "M"
  #/ "N" / "O" / "P" / "Q" / "R" / "S" / "T" / "U" / "V" / "W" / "X" / "Y" / "Z" / "_"

digit <-
   [0-9]
    #"0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"

keyword <- <(
    #"{any identifier listed in lex.key}"
    "alignas"
  | "alignof"
  | "asm"
  | "auto"
  | "bool"
  | "break"
  | "case"
  | "catch"
  | "char"
  | "char8_t"
  | "char16_t"
  | "char32_t"
  | "class"
  | "concept"
  | "const"
  | "consteval"
  | "constexpr"
  | "constinit"
  | "const_cast"
  | "continue"
  | "contract_assert"
  | "co_await"
  | "co_return"
  | "co_yield"
  | "decltype"
  | "default"
  | "delete"
  | "do"
  | "double"
  | "dynamic_cast"
  | "else"
  | "enum"
  | "explicit"
  | "export"
  | "extern"
  | "false"
  | "float"
  | "for"
  | "friend"
  | "goto"
  | "if"
  | "inline"
  | "int"
  | "long"
  | "mutable"
  | "namespace"
  | "new"
  | "noexcept"
  | "nullptr"
  | "operator"
  | "private"
  | "protected"
  | "public"
  | "register"
  | "reinterpret_cast"
  | "requires"
  | "return"
  | "short"
  | "signed"
  | "sizeof"
  | "static"
  | "static_assert"
  | "static_cast"
  | "struct"
  | "switch"
  | "template"
  | "this"
  | "thread_local"
  | "throw"
  | "true"
  | "try"
  | "typedef"
  | "typeid"
  | "typename"
  | "union"
  | "unsigned"
  | "using"
  | "virtual"
  | "void"
  | "volatile"
  | "wchar_t"
  | "while"
  | "import"
  | "module"
  | "export") !identifier_start>

preprocessing_op_or_punc <-
    preprocessing_operator
  / operator_or_punctuator

preprocessing_operator <-
    "#" / "##" / "%:" / "%:%:"

operator_or_punctuator <-
    "{" / "}" / "[" / "]" / "(" / ")"
  / "<:" / ":>" / "<%" / "%>" / ";" / ":" / "..."
  / "?" / "::" / "." / ".*" / "->" / "->*" / "~"
  / "!" / "+" / "-" / "*" / "/" / "%" / "^" / "&" / "|"
  / "=" / "+=" / "-=" / "*=" / "/=" / "%=" / "^=" / "&=" / "|="
  / "==" / "!=" / "<" / ">" / "<=" / ">=" / "<=>" / "&&" / "||"
  / "<<" / ">>" / "<<=" / ">>=" / "++" / "--" / ","
  / "and" / "or" / "xor" / "not" / "bitand" / "bitor" / "compl"
  / "and_eq" / "or_eq" / "xor_eq" / "not_eq"

literal <-
    integer_literal
  / character_literal
  / floating_point_literal
  / string_literal
  / boolean_literal
  / pointer_literal
  / user_defined_literal

integer_literal <-
    <binary_literal integer_suffix?>
  / <octal_literal integer_suffix?>
  / <decimal_literal integer_suffix?>
  / <hexadecimal_literal integer_suffix?>

binary_literal <-
    "0"[Bb] binary_digit ( "'"? binary_digit )*

octal_literal <-
    "0" ("'"? octal_digit)*

decimal_literal <-
    nonzero_digit ( "'"? digit)*

hexadecimal_literal <-
    hexadecimal_prefix hexadecimal_digit_sequence

binary_digit <-
    [01]
    #"0" / "1"

octal_digit <-
    [0-7]
    #"0" / "1" / "2" / "3" / "4" / "5" / "6" / "7"

nonzero_digit <-
    [1-9]
    #"1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"

hexadecimal_prefix <-
    "0x" / "0X"

hexadecimal_digit_sequence <-
    hexadecimal_digit ( "'"? hexadecimal_digit )*

hexadecimal_digit <-
    [0-9A-Fa-f]
  #  "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
  #/ "a" / "b" / "c" / "d" / "e" / "f"
  #/ "A" / "B" / "C" / "D" / "E" / "F"

integer_suffix <-
    unsigned_suffix long_suffix?
  / unsigned_suffix long_long_suffix?
  / unsigned_suffix size_suffix?
  / long_suffix unsigned_suffix?
  / long_long_suffix unsigned_suffix?
  / size_suffix unsigned_suffix?

unsigned_suffix <-
    "u" / "U"

long_suffix <-
    "l" / "L"

long_long_suffix <-
    "ll" / "LL"

size_suffix <-
   "z" / "Z"

character_literal <-
    <encoding_prefix? "'" c_char_sequence "'">

encoding_prefix <-
    "u8" / "u" / "U" / "L"

c_char_sequence <-
    c_char+

c_char <-
    basic_c_char
  / escape_sequence
  / universal_character_name

basic_c_char <-
    [^'\n'] #"{any member of the translation character set except the \unicode{0027}{apostrophe},}"
        #"{\unicode{005c}{reverse solidus}, or new_line character}"

escape_sequence <-
    simple_escape_sequence
  / numeric_escape_sequence
  / conditional_escape_sequence

simple_escape_sequence <-
    "\\" simple_escape_sequence_char

simple_escape_sequence_char <-
    "'" / '"' / "?" / "\\" / "a" / "b" / "f" / "n" / "r" / "t" / "v"

numeric_escape_sequence <-
    octal_escape_sequence
  / hexadecimal_escape_sequence

simple_octal_digit_sequence <-
    octal_digit+

octal_escape_sequence <-
    "\\" octal_digit
  / "\\" octal_digit octal_digit
  / "\\" octal_digit octal_digit octal_digit
  / "\\o{" simple_octal_digit_sequence "}"

hexadecimal_escape_sequence <-
    "\\x" simple_hexadecimal_digit_sequence
  / "\\x{" simple_hexadecimal_digit_sequence "}"

conditional_escape_sequence <-
    "\\" conditional_escape_sequence_char

conditional_escape_sequence_char <-
    '{any member of the basic character set that is not an octal_digit, a simple_escape_sequence_char, or the characters "N", "o", "u", "U", or "x"}'

floating_point_literal <-
    <decimal_floating_point_literal>
  / <hexadecimal_floating_point_literal>

decimal_floating_point_literal <-
    fractional_constant exponent_part? floating_point_suffix?
  / digit_sequence exponent_part floating_point_suffix?

hexadecimal_floating_point_literal <-
    hexadecimal_prefix hexadecimal_fractional_constant binary_exponent_part floating_point_suffix?
  / hexadecimal_prefix hexadecimal_digit_sequence binary_exponent_part floating_point_suffix?

fractional_constant <-
    digit_sequence? "." digit_sequence
  / digit_sequence "."

hexadecimal_fractional_constant <-
    hexadecimal_digit_sequence? "." hexadecimal_digit_sequence
  / hexadecimal_digit_sequence "."

exponent_part <-
    [Ee] sign? digit_sequence

binary_exponent_part <-
    [Pp] sign? digit_sequence

sign <-
    "+" / "-"

digit_sequence <-
    digit ( "'"? digit )*

floating_point_suffix <-
    "f" / "l" / "f16" / "f32" / "f64" / "f128" / "bf16" / "F" / "L" / "F16" / "F32" / "F64" / "F128" / "BF16"

string_literal <-
    <encoding_prefix? '"' s_char_sequence? '"'>
  / <encoding_prefix? "R" raw_string>

s_char_sequence <-
    s_char+

s_char <-
    basic_s_char
  / escape_sequence
  / universal_character_name

basic_s_char <-
    [^"\n"] #"{any member of the translation character set except the \unicode{0022}{quotation mark},}"
        #"{\unicode{005c}{reverse solidus}, or new_line character}"

raw_string <-
    '"' d_char_sequence? "(" r_char_sequence? ")" d_char_sequence? '"'

r_char_sequence <-
    r_char+

r_char <-
    [^)] #"{any member of the translation character set, except a \unicode{0029}{right parenthesis} followed by}"
        #"{the initial d_char_sequence (which may be empty) followed by a \unicode{0022}{quotation mark}}"

d_char_sequence <-
    d_char+

d_char <-
    [^ \t\f\v\n\r()] #"{any member of the basic character set except:}"
        #"{\unicode{0020}{space}, \unicode{0028}{left parenthesis}, \unicode{0029}{right parenthesis}, \unicode{005c}{reverse solidus},}"
        #"{\unicode{0009}{character tabulation}, \unicode{000b}{line tabulation}, \unicode{000c}{form feed}, and new_line}"

unevaluated_string <-
    string_literal

boolean_literal <-
    "false"
  / "true"

pointer_literal <-
    "nullptr"

user_defined_literal <-
    <user_defined_integer_literal>
  / <user_defined_floating_point_literal>
  / <user_defined_string_literal>
  / <user_defined_character_literal>

user_defined_integer_literal <-
    decimal_literal ud_suffix
  / octal_literal ud_suffix
  / hexadecimal_literal ud_suffix
  / binary_literal ud_suffix

user_defined_floating_point_literal <-
    fractional_constant exponent_part? ud_suffix
  / digit_sequence exponent_part ud_suffix
  / hexadecimal_prefix hexadecimal_fractional_constant binary_exponent_part ud_suffix
  / hexadecimal_prefix hexadecimal_digit_sequence binary_exponent_part ud_suffix

user_defined_string_literal <-
    string_literal ud_suffix

user_defined_character_literal <-
    character_literal ud_suffix

ud_suffix <-
    identifier

#== basic.tex

translation_unit <-
    declaration_seq?
  / global_module_fragment? module_declaration declaration_seq? private_module_fragment?

#== expressions.tex

primary_expression <-
    literal
  / "this"
  / "(" expression ")"
  / id_expression
  / lambda_expression
  / fold_expression
  / requires_expression

id_expression <-
    (unqualified_id
  / qualified_id) pack_index_expression*
  #/ pack_index_expression

unqualified_id <-
    identifier
  / operator_function_id
  / conversion_function_id
  / literal_operator_id
  / "~" type_name
  / "~" computed_type_specifier
  / template_id

qualified_id <-
    nested_name_specifier "template"? unqualified_id

nested_name_specifier <-
  ( type_name / namespace_name / computed_type_specifier )? '::' (
      ( identifier / 'template'? simple_template_id ) '::' )*
  #  "::"
  #/ type_name "::"
  #/ namespace_name "::"
  #/ computed_type_specifier "::"
  #/ nested_name_specifier identifier "::"
  #/ nested_name_specifier "template"? simple_template_id "::"

pack_index_expression <-
     "..." "[" constant_expression "]"
    #id_expression "..." "[" constant_expression "]"

lambda_expression <-
    lambda_introducer attribute_specifier_seq? lambda_declarator compound_statement
  / lambda_introducer "<" template_parameter_list ">" requires_clause? attribute_specifier_seq?
         lambda_declarator compound_statement

lambda_introducer <-
    "[" lambda_capture? "]"

lambda_declarator <-
    lambda_specifier_seq noexcept_specifier? attribute_specifier_seq? trailing_return_type?
  / noexcept_specifier attribute_specifier_seq? trailing_return_type?
  / trailing_return_type?
  / "(" parameter_declaration_clause ")" lambda_specifier_seq? noexcept_specifier? attribute_specifier_seq?
         trailing_return_type? requires_clause?

lambda_specifier <-
    "consteval"
  / "constexpr"
  / "mutable"
  / "static"

lambda_specifier_seq <-
    lambda_specifier
  / lambda_specifier lambda_specifier_seq

lambda_capture <-
    capture_default
  / capture_list
  / capture_default "," capture_list

capture_default <-
    "&"
  / "="

capture_list <-
    capture ( "," capture )*

capture <-
    simple_capture
  / init_capture

simple_capture <-
    identifier "..."?
  / "&" identifier "..."?
  / "this"
  / "*" "this"

init_capture <-
    "..."? identifier initializer
  / "&" "..."? identifier initializer

fold_expression <-
    "(" cast_expression fold_operator "..." ")"
  / "(" "..." fold_operator cast_expression ")"
  / "(" cast_expression fold_operator "..." fold_operator cast_expression ")"

fold_operator <-
    "+" / "-" / "*" / "/" / "%" / "^" / "&" / "|" / "<<" / ">>"
  / "+=" / "-=" / "*=" / "/=" / "%=" / "^=" / "&=" / "|=" / "<<=" / ">>=" / "="
  / "==" / "!=" / "<" / ">" / "<=" / ">=" / "&&" / "||" / "," / ".*" / "->*"

requires_expression <-
    "requires" requirement_parameter_list? requirement_body

requirement_parameter_list <-
    "(" parameter_declaration_clause ")"

requirement_body <-
    "{" requirement_seq "}"

requirement_seq <-
    requirement
  / requirement requirement_seq

requirement <-
    simple_requirement
  / type_requirement
  / compound_requirement
  / nested_requirement

simple_requirement <-
    expression ";"

type_requirement <-
    "typename" nested_name_specifier? type_name ";"

compound_requirement <-
    "{" expression "}" "noexcept"? return_type_requirement? ";"

return_type_requirement <-
    "->" type_constraint

nested_requirement <-
    "requires" constraint_expression ";"

postfix_expression <-
    ptfx_expr1 ptfx_expr2*
  #  primary_expression
  #/ simple_type_specifier "(" expression_list? ")"
  #/ typename_specifier "(" expression_list? ")"
  #/ simple_type_specifier braced_init_list
  #/ typename_specifier braced_init_list
  #/ "dynamic_cast" "<" type_id ">" "(" expression ")"
  #/ "static_cast" "<" type_id ">" "(" expression ")"
  #/ "reinterpret_cast" "<" type_id ">" "(" expression ")"
  #/ "const_cast" "<" type_id ">" "(" expression ")"
  #/ "typeid" "(" expression ")"
  #/ "typeid" "(" type_id ")"
  #/ postfix_expression "[" expression_list? "]"
  #/ postfix_expression "(" expression_list? ")"
  #/ postfix_expression "." "template"? id_expression
  #/ postfix_expression "->" "template"? id_expression
  #/ postfix_expression "++"
  #/ postfix_expression "--"

ptfx_expr1 <-
    primary_expression
  / simple_type_specifier "(" expression_list? ")"
  / typename_specifier "(" expression_list? ")"
  / simple_type_specifier braced_init_list
  / typename_specifier braced_init_list
  / "dynamic_cast" "<" type_id ">" "(" expression ")"
  / "static_cast" "<" type_id ">" "(" expression ")"
  / "reinterpret_cast" "<" type_id ">" "(" expression ")"
  / "const_cast" "<" type_id ">" "(" expression ")"
  / "typeid" "(" expression ")"
  / "typeid" "(" type_id ")"

ptfx_expr2 <-
    "[" expression_list? "]"
  / "(" expression_list? ")"
  / "." "template"? id_expression
  / "->" "template"? id_expression
  / "++"
  / "--"

expression_list <-
    initializer_list

unary_expression <-
    postfix_expression
  / unary_operator cast_expression
  / "++" cast_expression
  / "--" cast_expression
  / await_expression
  / "sizeof" unary_expression
  / "sizeof" "(" type_id ")"
  / "sizeof" "..." "(" identifier ")"
  / "alignof" "(" type_id ")"
  / noexcept_expression
  / new_expression
  / delete_expression

unary_operator <-
    "*" / "&" / "+" / "-" / "!" / "~"

await_expression <-
    "co_await" cast_expression

noexcept_expression <-
  "noexcept" "(" expression ")"

new_expression <-
    "::"? "new" new_placement? new_type_id new_initializer?
  / "::"? "new" new_placement? "(" type_id ")" new_initializer?

new_placement <-
    "(" expression_list ")"

new_type_id <-
    type_specifier_seq new_declarator?

new_declarator <-
    ptr_operator new_declarator?
  / noptr_new_declarator

noptr_new_declarator <-
    "[" expression? "]" attribute_specifier_seq? ( "[" constant_expression "]" attribute_specifier_seq? )*

new_initializer <-
    "(" expression_list? ")"
  / braced_init_list

delete_expression <-
    "::"? "delete" cast_expression
  / "::"? "delete" "[" "]" cast_expression

cast_expression <-
    unary_expression
  / "(" type_id ")" cast_expression

pm_expression <-
    cast_expression ( (".*" / "->*") cast_expression )*

multiplicative_expression <-
    pm_expression ( ("*" /  "/" / "%") pm_expression )*

additive_expression <-
    multiplicative_expression ( ("+" / "-") multiplicative_expression )*

shift_expression <-
    additive_expression ( ("<<" / ">>") additive_expression )*

compare_expression <-
    shift_expression ( "<=>" shift_expression )*

relational_expression <-
    compare_expression ( ("<" / ">" / "<=" / ">=") compare_expression )*

equality_expression <-
    relational_expression ( ("==" / "!=") relational_expression )*

and_expression <-
    equality_expression ( "&" equality_expression )*

exclusive_or_expression <-
    and_expression ( "^" and_expression )*

inclusive_or_expression <-
    exclusive_or_expression ( "|" exclusive_or_expression )*

logical_and_expression <-
    inclusive_or_expression ( "&&" inclusive_or_expression )*

logical_or_expression <-
    logical_and_expression ( "||" logical_and_expression )*

conditional_expression <-
    logical_or_expression
  / logical_or_expression "?" expression ":" assignment_expression

  yield_expression <-
  "co_yield" assignment_expression
  / "co_yield" braced_init_list

throw_expression <-
    "throw"  assignment_expression?

assignment_expression <-
   logical_or_expression assignment_operator initializer_clause
  / conditional_expression
  / yield_expression
  / throw_expression

assignment_operator <-
    "=" / "*=" / "/=" / "%=" / "+=" / "-=" / ">>=" / "<<=" / "&=" / "^=" / "|="

expression <-
    assignment_expression ( "," assignment_expression )*

constant_expression <-
    conditional_expression

#== statements.tex

statement <-
    labeled_statement
  / attribute_specifier_seq? expression_statement
  / attribute_specifier_seq? compound_statement
  / attribute_specifier_seq? selection_statement
  / attribute_specifier_seq? iteration_statement
  / attribute_specifier_seq? jump_statement
  / declaration_statement
  / attribute_specifier_seq? try_block

init_statement <-
    expression_statement
  / simple_declaration
  / alias_declaration

condition <-
    expression
  / attribute_specifier_seq? decl_specifier_seq declarator brace_or_equal_initializer

label <-
    attribute_specifier_seq? identifier ":"
  / attribute_specifier_seq? "case" constant_expression ":"
  / attribute_specifier_seq? "default" ":"

labeled_statement <-
    label statement

expression_statement <-
    expression? ";"

compound_statement <-
    "{" statement_seq? label_seq? "}"

statement_seq <-
    statement+

label_seq <-
    label+

selection_statement <-
    "if" "constexpr"? "(" init_statement? condition ")" statement "else" statement
  / "if" "constexpr"? "(" init_statement? condition ")" statement
  / "if" "!"? "consteval" compound_statement "else" statement
  / "if" "!"? "consteval" compound_statement
  / "switch" "(" init_statement? condition ")" statement

iteration_statement <-
    "while" "(" condition ")" statement
  / "do" statement "while" "(" expression ")" ";"
  / "for" "(" init_statement condition? ";" expression? ")" statement
  / "for" "(" init_statement? for_range_declaration ":" for_range_initializer ")" statement

for_range_declaration <-
    attribute_specifier_seq? decl_specifier_seq declarator
  / attribute_specifier_seq? decl_specifier_seq ref_qualifier? "[" identifier_list "]"

for_range_initializer <-
    expr_or_braced_init_list

jump_statement <-
    "break" ";"
  / "continue" ";"
  / "return" expr_or_braced_init_list? ";"
  / coroutine_return_statement
  / "goto" identifier ";"

coroutine_return_statement <-
    "co_return" expr_or_braced_init_list? ";"

declaration_statement <-
    block_declaration

#== declarations.tex

declaration_seq <-
    declaration+

declaration <-
    name_declaration
  / special_declaration

name_declaration <-
    block_declaration
  / nodeclspec_function_declaration
  / function_definition
  / template_declaration
  / deduction_guide
  / linkage_specification
  / namespace_definition
  / empty_declaration
  / attribute_declaration
  / module_import_declaration

special_declaration <-
    explicit_instantiation
  / explicit_specialization
  / export_declaration

block_declaration <-
    simple_declaration
  / asm_declaration
  / namespace_alias_definition
  / using_declaration
  / using_enum_declaration
  / using_directive
  / static_assert_declaration
  / alias_declaration
  / opaque_enum_declaration

nodeclspec_function_declaration <-
    attribute_specifier_seq? declarator ";"

alias_declaration <-
    "using" identifier attribute_specifier_seq? "=" defining_type_id ";"

simple_declaration <-
    decl_specifier_seq init_declarator_list? ";"
  / attribute_specifier_seq decl_specifier_seq init_declarator_list ";"
  / attribute_specifier_seq? decl_specifier_seq ref_qualifier? "[" identifier_list "]" initializer ";"

static_assert_message <-
  unevaluated_string
  / constant_expression

static_assert_declaration <-
  "static_assert" "(" constant_expression ")" ";"
  / "static_assert" "(" constant_expression "," static_assert_message ")" ";"

empty_declaration <-
    ";"

attribute_declaration <-
    attribute_specifier_seq ";"

decl_specifier <-
    storage_class_specifier
  / defining_type_specifier
  / function_specifier
  / "friend"
  / "typedef"
  / "constexpr"
  / "consteval"
  / "constinit"
  / "inline"

decl_specifier_seq <-
    decl_specifier+ attribute_specifier_seq?

storage_class_specifier <-
    "static"
  / "thread_local"
  / "extern"
  / "mutable"

function_specifier <-
    "virtual"
  / explicit_specifier

explicit_specifier <-
    "explicit" "(" constant_expression ")"
  / "explicit"

typedef_name <-
    "$" identifier
  / simple_template_id

type_specifier <-
  simple_type_specifier
  / elaborated_type_specifier
  / typename_specifier
  / cv_qualifier

type_specifier_seq <-
    type_specifier attribute_specifier_seq?
  / type_specifier type_specifier_seq

defining_type_specifier <-
    type_specifier
  / class_specifier
  / enum_specifier

defining_type_specifier_seq <-
  defining_type_specifier attribute_specifier_seq?
  / defining_type_specifier defining_type_specifier_seq

simple_type_specifier <-
    "char8_t"
  / "char16_t"
  / "char32_t"
  / "char"
  / "wchar_t"
  / "bool"
  / "short"
  / "int"
  / "long"
  / "signed"
  / "unsigned"
  / "float"
  / "double"
  / "void"
  / nested_name_specifier? type_name
  / nested_name_specifier? template_name
  / nested_name_specifier "template" simple_template_id
  / computed_type_specifier
  / placeholder_type_specifier

type_name <-
    class_name
  / enum_name
  / typedef_name

computed_type_specifier <-
    decltype_specifier
  / pack_index_specifier

pack_index_specifier <-
    typedef_name "..." "[" constant_expression "]"

elaborated_type_specifier <-
    class_key attribute_specifier_seq? nested_name_specifier? identifier
  / class_key simple_template_id
  / class_key nested_name_specifier "template"? simple_template_id
  / "enum" nested_name_specifier? identifier

decltype_specifier <-
  "decltype" "(" expression ")"

placeholder_type_specifier <-
  type_constraint? "auto"
  / type_constraint? "decltype" "(" "auto" ")"

init_declarator_list <-
    init_declarator ( "," init_declarator )*

init_declarator <-
    declarator initializer?
  / declarator requires_clause

declarator <-
    ptr_declarator
  / noptr_declarator parameters_and_qualifiers trailing_return_type

ptr_declarator <-
    noptr_declarator
  / ptr_operator ptr_declarator

noptr_declarator <-
  ( declarator_id attribute_specifier_seq? / '(' ptr_declarator ')' )
    ( parameters_and_qualifiers / '[' constant_expression? ']' attribute_specifier_seq? )*
  #  declarator_id attribute_specifier_seq?
  #/ noptr_declarator parameters_and_qualifiers
  #/ noptr_declarator "[" constant_expression? "]" attribute_specifier_seq?
  #/ "(" ptr_declarator ")"

parameters_and_qualifiers <-
    "(" parameter_declaration_clause ")" cv_qualifier_seq?
        ref_qualifier? noexcept_specifier? attribute_specifier_seq?

trailing_return_type <-
    "->" type_id

ptr_operator <-
    "*" attribute_specifier_seq? cv_qualifier_seq?
  / "&" attribute_specifier_seq?
  / "&&" attribute_specifier_seq?
  / nested_name_specifier "*" attribute_specifier_seq? cv_qualifier_seq?

cv_qualifier_seq <-
    cv_qualifier cv_qualifier_seq?

cv_qualifier <-
    "const"
  / "volatile"

ref_qualifier <-
    "&"
  / "&&"

declarator_id <-
    "..."? id_expression

type_id <-
    type_specifier_seq abstract_declarator?

defining_type_id <-
    defining_type_specifier_seq abstract_declarator?

abstract_declarator <-
    ptr_abstract_declarator
  / noptr_abstract_declarator? parameters_and_qualifiers trailing_return_type
  / abstract_pack_declarator

ptr_abstract_declarator <-
    noptr_abstract_declarator
  / ptr_operator ptr_abstract_declarator?

noptr_abstract_declarator <-
  ( parameters_and_qualifiers
    / '[' constant_expression? ']' attribute_specifier_seq?
    / '(' ptr_abstract_declarator ')' )
    ( parameters_and_qualifiers / '[' constant_expression? ']' attribute_specifier_seq? )*
  #  noptr_abstract_declarator? parameters_and_qualifiers
  #/ noptr_abstract_declarator? "[" constant_expression? "]" attribute_specifier_seq?
  #/ "(" ptr_abstract_declarator ")"

abstract_pack_declarator <-
    noptr_abstract_pack_declarator
  / ptr_operator abstract_pack_declarator

noptr_abstract_pack_declarator <-
    "..." parameters_and_qualifiers*

parameter_declaration_clause <-
    parameter_declaration_list? "..."?
  / parameter_declaration_list "," "..."

parameter_declaration_list <-
    parameter_declaration ( "," parameter_declaration )*

parameter_declaration <-
    attribute_specifier_seq? "this"? decl_specifier_seq declarator
  / attribute_specifier_seq? decl_specifier_seq declarator "=" initializer_clause
  / attribute_specifier_seq? "this"? decl_specifier_seq abstract_declarator?
  / attribute_specifier_seq? decl_specifier_seq abstract_declarator? "=" initializer_clause

initializer <-
    brace_or_equal_initializer
  / "(" expression_list ")"

brace_or_equal_initializer <-
    "=" initializer_clause
  / braced_init_list

initializer_clause <-
    assignment_expression
  / braced_init_list

braced_init_list <-
    "{" initializer_list ","? "}"
  / "{" designated_initializer_list ","? "}"
  / "{" "}"

initializer_list <-
    initializer_clause "..."? ( "," initializer_clause "..."? )*

designated_initializer_list <-
    designated_initializer_clause ( "," designated_initializer_clause )*

designated_initializer_clause <-
    designator brace_or_equal_initializer

designator <-
    "." identifier

expr_or_braced_init_list <-
    expression
  / braced_init_list

function_definition <-
    attribute_specifier_seq? decl_specifier_seq? declarator virt_specifier_seq? function_body
  / attribute_specifier_seq? decl_specifier_seq? declarator requires_clause function_body

function_body <-
    ctor_initializer? compound_statement
  / function_try_block
  / "=" "default" ";"
  / "=" "delete" ";"

enum_name <-
    '$' identifier

enum_specifier <-
    enum_head "{" enumerator_list? "}"
  / enum_head "{" enumerator_list "," "}"

enum_head <-
    enum_key attribute_specifier_seq? enum_head_name? enum_base?

enum_head_name <-
    nested_name_specifier? identifier

opaque_enum_declaration <-
    enum_key attribute_specifier_seq? enum_head_name enum_base? ";"

enum_key <-
    "enum"
  / "enum" "class"
  / "enum" "struct"

enum_base <-
    ":" type_specifier_seq

enumerator_list <-
    enumerator_definition ( "," enumerator_definition )*

enumerator_definition <-
    enumerator
  / enumerator "=" constant_expression

enumerator <-
    identifier attribute_specifier_seq?

using_enum_declaration <-
    "using" "enum" using_enum_declarator ";"

using_enum_declarator <-
    nested_name_specifier? identifier
  / nested_name_specifier? simple_template_id

namespace_name <-
        identifier
  / namespace_alias

namespace_definition <-
        named_namespace_definition
  / unnamed_namespace_definition
  / nested_namespace_definition

named_namespace_definition <-
        "inline"? "namespace" attribute_specifier_seq? identifier "{" namespace_body "}"

unnamed_namespace_definition <-
        "inline"? "namespace" attribute_specifier_seq? "{" namespace_body "}"

nested_namespace_definition <-
        "namespace" enclosing_namespace_specifier "::" "inline"? identifier "{" namespace_body "}"

enclosing_namespace_specifier <-
        identifier ( "::" "inline"? identifier )*

namespace_body <-
        declaration_seq?

namespace_alias <-
        identifier

namespace_alias_definition <-
        "namespace" identifier "=" qualified_namespace_specifier ";"

qualified_namespace_specifier <-
    nested_name_specifier? namespace_name

using_directive <-
    attribute_specifier_seq? "using" "namespace" nested_name_specifier? namespace_name ";"

using_declaration <-
    "using" using_declarator_list ";"

using_declarator_list <-
    using_declarator "..."? ( "," using_declarator "..."? )*

using_declarator <-
    "typename"? nested_name_specifier unqualified_id

asm_declaration <-
    attribute_specifier_seq? "asm" "(" balanced_token_seq ")" ";"

linkage_specification <-
    "extern" unevaluated_string "{" declaration_seq? "}"
  / "extern" unevaluated_string name_declaration

attribute_specifier_seq <-
  attribute_specifier+
  #attribute_specifier_seq? attribute_specifier

attribute_specifier <-
  "[" "[" attribute_using_prefix? attribute_list "]" "]"
  / alignment_specifier

alignment_specifier <-
  "alignas" "(" type_id "..."? ")"
  / "alignas" "(" constant_expression "..."? ")"

attribute_using_prefix <-
  "using" attribute_namespace ":"

attribute_list <-
  (attribute "..."? (',' attribute "..."?)* ','?)?
  #attribute?
  #/ attribute_list "," attribute?
  #/ attribute "..."
  #/ attribute_list "," attribute "..."

attribute <-
    attribute_token attribute_argument_clause?

attribute_token <-
    identifier
  / attribute_scoped_token

attribute_scoped_token <-
    attribute_namespace "::" identifier

attribute_namespace <-
    identifier

attribute_argument_clause <-
    "(" balanced_token_seq? ")"

balanced_token_seq <-
    balanced_token+

balanced_token <-
    "(" balanced_token_seq? ")"
  / "[" balanced_token_seq? "]"
  / "{" balanced_token_seq? "}"
  / "{any token other than a parenthesis, a bracket, or a brace}"

#== modules.tex

module_declaration <-
    "export"? "module" module_name module_partition? attribute_specifier_seq? ";"

module_name <-
    module_name_qualifier? identifier

module_partition <-
    ":" module_name_qualifier? identifier

module_name_qualifier <-
    identifier "." ( identifier "." )*

export_declaration <-
    "export" name_declaration
  / "export" "{" declaration_seq? "}"
  / "export" module_import_declaration

module_import_declaration <-
    "import" module_name attribute_specifier_seq? ";"
  / "import" module_partition attribute_specifier_seq? ";"
  / "import" header_name attribute_specifier_seq? ";"

global_module_fragment <-
    "module" ";" declaration_seq?

private_module_fragment <-
    "module" ":" "private" ";" declaration_seq?

#== classes.tex

class_name <-
    '$' identifier
  / simple_template_id

class_specifier <-
    class_head "{" member_specification? "}"

class_head <-
    class_key attribute_specifier_seq? class_head_name class_virt_specifier? base_clause?
  / class_key attribute_specifier_seq? base_clause?

class_head_name <-
    nested_name_specifier? class_name

class_virt_specifier <-
    "final"

class_key <-
    "class"
  / "struct"
  / "union"

member_specification <-
    member_declaration member_specification?
  / access_specifier ":" member_specification?

member_declaration <-
    attribute_specifier_seq? decl_specifier_seq? member_declarator_list? ";"
  / function_definition
  / using_declaration
  / using_enum_declaration
  / static_assert_declaration
  / template_declaration
  / explicit_specialization
  / deduction_guide
  / alias_declaration
  / opaque_enum_declaration
  / empty_declaration

member_declarator_list <-
    member_declarator ( "," member_declarator )*

member_declarator <-
    declarator virt_specifier_seq? pure_specifier?
  / declarator requires_clause
  / declarator brace_or_equal_initializer?
  / identifier? attribute_specifier_seq? ":" constant_expression brace_or_equal_initializer?

virt_specifier_seq <-
    virt_specifier+

virt_specifier <-
    "override"
  / "final"

pure_specifier <-
    "=" "0"

conversion_function_id <-
    "operator" conversion_type_id

conversion_type_id <-
    type_specifier_seq conversion_declarator?

conversion_declarator <-
    ptr_operator conversion_declarator?

base_clause <-
    ":" base_specifier_list

base_specifier_list <-
    base_specifier "..."? ( "," base_specifier "..."? )*

base_specifier <-
    attribute_specifier_seq? class_or_decltype
  / attribute_specifier_seq? "virtual" access_specifier? class_or_decltype
  / attribute_specifier_seq? access_specifier "virtual"? class_or_decltype

class_or_decltype <-
    nested_name_specifier? type_name
  / nested_name_specifier "template" simple_template_id
  / decltype_specifier

access_specifier <-
    "private"
  / "protected"
  / "public"

ctor_initializer <-
    ":" mem_initializer_list

mem_initializer_list <-
    mem_initializer "..."? ( "," mem_initializer "..."? )*

mem_initializer <-
    mem_initializer_id "(" expression_list? ")"
  / mem_initializer_id braced_init_list

mem_initializer_id <-
    class_or_decltype
  / identifier

#== overloading.tex

operator_function_id <-
    "operator" operator

operator <-
    "new" / "delete" / "new[]" / "delete[]" / "co_await" / "()" / "[]" / "->" / "->*"
  / "~" / "!" / "+" / "-" / "*" / "/" / "%" / "^" / "&"
  / "|" / "=" / "+=" / "-=" / "*=" / "/=" / "%=" / "^=" / "&="
  / "|=" / "==" / "!=" / "<" / ">" / "<=" / ">=" / "<=>" / "&&"
  / "||" / "<<" / ">>" / "<<=" / ">>=" / "++" / "--" / ","

literal_operator_id <-
    "operator" unevaluated_string identifier
  / "operator" user_defined_string_literal

#== templates.tex

template_declaration <-
  template_head declaration
  / template_head concept_definition

template_head <-
  "template" "<" template_parameter_list ">" requires_clause?

template_parameter_list <-
  template_parameter ( "," template_parameter )*

requires_clause <-
  "requires" constraint_logical_or_expression

constraint_logical_or_expression <-
  constraint_logical_and_expression ( "||" constraint_logical_and_expression )*

constraint_logical_and_expression <-
  primary_expression ( "&&" primary_expression )*

template_parameter <-
  type_parameter
  / parameter_declaration

type_parameter <-
  type_parameter_key "..."? identifier?
  / type_parameter_key identifier? "=" type_id
  / type_constraint "..."? identifier?
  / type_constraint identifier? "=" type_id
  / template_head type_parameter_key "..."? identifier?
  / template_head type_parameter_key identifier? "=" id_expression

type_parameter_key <-
  "class"
  / "typename"

type_constraint <-
  nested_name_specifier? concept_name
  / nested_name_specifier? concept_name "<" template_argument_list? ">"

simple_template_id <-
  template_name "<" template_argument_list? ">"

template_id <-
  simple_template_id
  / operator_function_id "<" template_argument_list? ">"
  / literal_operator_id "<" template_argument_list? ">"

template_name <-
  "$" identifier

template_argument_list <-
  template_argument "..."? ( "," template_argument "..."? )*

template_argument <-
  constant_expression
  / type_id
  / id_expression
  / braced_init_list

constraint_expression <-
    logical_or_expression

deduction_guide <-
    explicit_specifier? template_name "(" parameter_declaration_clause ")" "->" simple_template_id ";"

concept_definition <-
  "concept" concept_name attribute_specifier_seq? "=" constraint_expression ";"

concept_name <-
  identifier

typename_specifier <-
  "typename" nested_name_specifier identifier
  / "typename" nested_name_specifier "template"? simple_template_id

explicit_instantiation <-
  "extern"? "template" declaration

explicit_specialization <-
  "template" "<" ">" declaration

#== exceptions.tex

try_block <-
    "try" compound_statement handler_seq

function_try_block <-
    "try" ctor_initializer? compound_statement handler_seq

handler_seq <-
    handler handler_seq?

handler <-
    "catch" "(" exception_declaration ")" compound_statement

exception_declaration <-
    attribute_specifier_seq? type_specifier_seq declarator
  / attribute_specifier_seq? type_specifier_seq abstract_declarator?
  / "..."

noexcept_specifier <-
    "noexcept" "(" constant_expression ")"
  / "noexcept"

#== preprocessor.tex

preprocessing_file <-
    group?
  / module_file

module_file <-
    pp_global_module_fragment? pp_module group? pp_private_module_fragment?

pp_global_module_fragment <-
    "module" ";" new_line group?

pp_private_module_fragment <-
    "module" ":" "private" ";" new_line group?

group <-
    group_part+

group_part <-
    control_line
  / if_section
  / text_line
  / "#" conditionally_supported_directive

control_line <-
    "#" "include" pp_tokens new_line
  / pp_import
  / "#" "define" identifier replacement_list new_line
  / "#" "define" identifier lparen identifier_list? ")" replacement_list new_line
  / "#" "define" identifier lparen "..." ")" replacement_list new_line
  / "#" "define" identifier lparen identifier_list "," "..." ")" replacement_list new_line
  / "#" "undef" identifier new_line
  / "#" "line" pp_tokens new_line
  / "#" "error" pp_tokens? new_line
  / "#" "warning" pp_tokens? new_line
  / "#" "pragma" pp_tokens? new_line
  / "#" new_line

if_section <-
    if_group elif_groups? else_group? endif_line

if_group <-
    "#" "if" constant_expression new_line group?
  / "#" "ifdef" identifier new_line group?
  / "#" "ifndef" identifier new_line group?

elif_groups <-
    elif_group+

elif_group <-
    "#" "elif" constant_expression new_line group?
  / "#" "elifdef" identifier new_line group?
  / "#" "elifndef" identifier new_line group?

else_group <-
    "#" "else" new_line group?

endif_line <-
    "#" "endif" new_line

text_line <-
    pp_tokens? new_line

conditionally_supported_directive <-
    pp_tokens new_line

lparen <-
    [(] !WS #'{a "(" character not immediately preceded by whitespace}'

identifier_list <-
    identifier ( "," identifier )*

replacement_list <-
    pp_tokens?

pp_tokens <-
    preprocessing_token+

new_line <-
    "{the new_line character}"

#defined_macro_expression <-
#    "defined" identifier
#  / "defined" "(" identifier ")"

h_preprocessing_token <-
    '{any preprocessing_token other than ">"}'

h_pp_tokens <-
    h_preprocessing_token+

header_name_tokens <-
    string_literal
  / "<" h_pp_tokens ">"

#has_include_expression <-
#    "has_include" "(" header_name ")"
#  / "has_include" "(" header_name_tokens ")"

#has_attribute_expression <-
#    "has_cpp_attribute" "(" pp_tokens ")"

pp_module <-
    "export"? "module" pp_tokens? ";" new_line

pp_import <-
    "export"? "import" header_name pp_tokens? ";" new_line
  / "export"? "import" header_name_tokens pp_tokens? ";" new_line
  / "export"? "import" pp_tokens ";" new_line

#va_opt_replacement <-
#    "VA_OPT" "(" pp_tokens? ")"

COMMENT <- "//"[^\n]* / "/*" (!"*/" .)* "*/"
WS <- [ \t\r\n\f\v]
%whitespace <- (WS+ / COMMENT)*
