#//ISO/IEC 9899:TC3 Committee Draft — Septermber 7, 2007 WG14/N1256

#//
#// EBNF to be viewd at https://www.bottlecaps.de/rr/ui
#//
#// Copy and paste this at https://www.bottlecaps.de/rr/ui in the 'Edit Grammar' tab
#// then click the 'View Diagram' tab.
#//

#//
#//To facilitate start navigating
#//

std_c17 <-
	(&'#' preprocessing_file)? translation_unit

#//A.1 Lexical grammar
#//A.1.1 Lexical elements
#//(6.4)
#token <-
#	keyword
#	/ identifier
#	/ constant
#	/ string_literal
#	/ punctuator

#//(6.4)
preprocessing_token <-
	header_name
	/ identifier
	/ pp_number
	/ character_constant
	/ string_literal
	/ punctuator
	#/ "{ each non-white-space character that cannot be one of the above }"

#//A.1.2 Keywords
#//(6.4.1)
keyword <- <(
	"auto"
	| "break"
	| "case"
	| "char"
	| "const"
	| "continue"
	| "default"
	| "do"
	| "double"
	| "else"
	| "enum"
	| "extern"
	| "float"
	| "for"
	| "goto"
	| "if"
	| "inline"
	| "int"
	| "long"
	| "register"
	| "restrict"
	| "return"
	| "short"
	| "signed"
	| "sizeof"
	| "static"
	| "struct"
	| "switch"
	| "typedef"
	| "union"
	| "unsigned"
	| "void"
	| "volatile"
	| "while"
	| "_Alignas"
	| "_Alignof"
	| "_Atomic"
	| "_Bool"
	| "_Complex"
	| "_Generic"
	| "_Imaginary"
	| "_Noreturn"
	| "_Static_assert"
	| "_Thread_local" ) !identifier_nondigit>

#//§A.1.2 Language syntax summary 403
#//A.1.3 Identifiers
#//(6.4.2.1)
identifier <-
	!keyword <identifier_nondigit ( identifier_nondigit / digit )*>

#//(6.4.2.1)
identifier_nondigit <-
	nondigit
	/ universal_character_name
	#/ "{ other implementation-defined characters }"

#//(6.4.2.1)
nondigit <-
	[A-Za-z_]
	#'_' / 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g' / 'h' / 'i' / 'j' / 'k' / 'l' / 'm'
	#/ 'n' / 'o' / 'p' / 'q' / 'r' / 's' / 't' / 'u' / 'v' / 'w' / 'x' / 'y' / 'z'
	#/ 'A' / 'B' / 'C' / 'D' / 'E' / 'F' / 'G' / 'H' / 'I' / 'J' / 'K' / 'L' / 'M'
	#/ 'N' / 'O' / 'P' / 'Q' / 'R' / 'S' / 'T' / 'U' / 'V' / 'W' / 'X' / 'Y' / 'Z'

#//(6.4.2.1)
digit <-
	[0-9]
	#'0' / '1' / '2' / '3' / '4' / '5' / '6' / '7' / '8' / '9'

#//A.1.4 Universal character names
#//(6.4.3)
universal_character_name <-
	"\\u" hex_quad
	/ "\\U" hex_quad hex_quad

#//(6.4.3)
hex_quad <-
	hexadecimal_digit{4}
	#hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit

#//A.1.5 Constants
#//(6.4.4)
constant <-
	integer_constant
	/ floating_constant
	/ enumeration_constant
	/ character_constant

#//(6.4.4.1)
integer_constant <-
	<decimal_constant integer_suffix?>
	/ <octal_constant integer_suffix?>
	/ <hexadecimal_constant integer_suffix?>

#//(6.4.4.1)
decimal_constant <-
	nonzero_digit digit*

#//(6.4.4.1)
octal_constant <-
	'0' octal_digit*

#//(6.4.4.1)
hexadecimal_constant <-
	hexadecimal_prefix hexadecimal_digit+

#//(6.4.4.1)
hexadecimal_prefix <-
	"0x" / "0X"

#//(6.4.4.1)
nonzero_digit <-
	[1-9]
	#'1' / '2' / '3' / '4' / '5' / '6' / '7' / '8' / '9'

#//(6.4.4.1)
octal_digit <-
	[0-7]
	#'0' / '1' / '2' / '3' / '4' / '5' / '6' / '7'

#//(6.4.4.1)
hexadecimal_digit <-
	[0-9A-Fa-f]
	#'0' / '1' / '2' / '3' / '4' / '5' / '6' / '7' / '8' / '9'
	#/ 'a' / 'b' / 'c' / 'd' / 'e' / 'f'
	#/ 'A' / 'B' / 'C' / 'D' / 'E' / 'F'

#//(6.4.4.1)
integer_suffix <-
	unsigned_suffix long_suffix?
	/ unsigned_suffix long_long_suffix
	/ long_suffix unsigned_suffix?
	/ long_long_suffix unsigned_suffix?

#//(6.4.4.1)
unsigned_suffix <-
	[Uu]
	#'u' / 'U'

#//(6.4.4.1)
long_suffix <-
	[Ll]
	#'l' / 'L'

#//(6.4.4.1)
long_long_suffix <-
	"ll" / "LL"

#//(6.4.4.2)
floating_constant <-
	<decimal_floating_constant>
	/ <hexadecimal_floating_constant>

#//(6.4.4.2)
decimal_floating_constant <-
	fractional_constant exponent_part? floating_suffix?
	/ digit_sequence exponent_part floating_suffix?

#//(6.4.4.2)
hexadecimal_floating_constant <-
	hexadecimal_prefix hexadecimal_fractional_constant
	/ binary_exponent_part floating_suffix?
	/ hexadecimal_prefix hexadecimal_digit_sequence
	/ binary_exponent_part floating_suffix?

#//(6.4.4.2)
fractional_constant <-
	digit_sequence? '.' digit_sequence
	/ digit_sequence '.'

#//(6.4.4.2)
exponent_part <-
	[Ee] sign? digit_sequence

#//(6.4.4.2)
sign <-
	[+-]
	#'+' / '-'

#//(6.4.4.2)
digit_sequence <-
	digit+

#//(6.4.4.2)
hexadecimal_fractional_constant <-
	hexadecimal_digit_sequence? '.'
	/ hexadecimal_digit_sequence
	/ hexadecimal_digit_sequence '.'

#//(6.4.4.2)
binary_exponent_part <-
	[Pp] sign? digit_sequence

#//(6.4.4.2)
hexadecimal_digit_sequence <-
	hexadecimal_digit+

#//(6.4.4.2)
floating_suffix <-
	"fl" / "FL"

#//(6.4.4.3)
enumeration_constant <-
	identifier

#//(6.4.4.4)
character_constant <-
	<[LUu]? "'" c_char_sequence "'">

#//(6.4.4.4)
c_char_sequence <-
	c_char+

#//(6.4.4.4)
c_char <-
	[^'\r\n\\'] #"{ any member of the source character set except the single-quote ', backslash \, or new-line character }"
	/ escape_sequence

#//(6.4.4.4)
escape_sequence <-
	simple_escape_sequence
	/ octal_escape_sequence
	/ hexadecimal_escape_sequence
	/ universal_character_name

#//(6.4.4.4)
simple_escape_sequence <-
	"\\"['"?\\abfnrtv]
	#"\\'" / '\\"' / "\\?" / "\\\\"
	#/ "\\a" / "\\b" / "\\f" / "\\n" / "\\r" / "\\t" / "\\v"

#//(6.4.4.4)
octal_escape_sequence <-
	'\\' octal_digit{1,3}

#//(6.4.4.4)
hexadecimal_escape_sequence <-
	"\\x" hexadecimal_digit+

#//A.1.6 String literals
#//(6.4.5)
string_literal <-
	<encoding_prefix? '"' s_char_sequence? '"'>

#//(6.4.5)
encoding_prefix <-
	"u8" / 'u' / 'U' / 'L'

#//(6.4.5)
s_char_sequence <-
	s_char+

#//(6.4.5)
s_char <-
	[^"\r\n\\] #'{ any member of the source character set except the double-quote ", backslash \, or new-line character }'
	/ escape_sequence

#//A.1.7 Punctuators
#//(6.4.6)
punctuator <-
	'[' / ']' / '(' / ')' / '{' / '}' / '.' / "->"
	/ "++" / "--" / '&' / '*' / '+' / '-' / '~' / '!'
	/ '/' / '%' / "<<" / ">>" / '<' / '>' / "<=" / ">=" / "==" / "!=" / '^' / '|' / "&&" / "||"
	/ '?' / ':' / ';' / "..."
	/ assignment_operator
	#/ '=' / "*=" / "/=" / "%=" / "+=" / "-=" / "<<=" / ">>=" / "&=" / "^=" / "|="
	/ ',' / '#' / "##"
	/ "<:" / ":>" / "<%" / "%>" / "%:" / "%:%:"

#//A.1.8 Header names
#//(6.4.7)
header_name <-
	<'<' h_char_sequence '>'
	/ '"' q_char_sequence '"'>

#//(6.4.7)
h_char_sequence <-
	h_char+

#//(6.4.7)
h_char <-
	[^>\n\r] #"{ any member of the source character set except the new-line character and > }"

#//(6.4.7)
q_char_sequence <-
	q_char+

#//(6.4.7)
q_char <-
	[^"\n\r"] #'{ any member of the source character set except the new-line character and " }'

#//A.1.9 Preprocessing numbers
#//(6.4.8)
pp_number <-
	<(digit / '.' digit) ( digit / identifier_nondigit / [EePp] sign / '.' )*>

#//A.2 Phrase structure grammar
#//A.2.1 Expressions
#//(6.5.1)
primary_expression <-
	identifier
	/ constant
	/ string_literal
	/ '(' expression ')'
	/ generic_selection

#//(6.5.1.1)
generic_selection <-
	"_Generic" '(' assignment_expression ',' generic_assoc_list ')'

#//(6.5.1.1)
generic_assoc_list <-
	generic_association ( ',' generic_association )*

#//(6.5.1.1)
generic_association <-
	type_name ':' assignment_expression
	/ "default" ':' assignment_expression

#//(6.5.2)
postfix_expression <-
	(primary_expression / '(' type_name ')' '{' initializer_list ','? '}') (
    	  '[' expression ']'
    	/ '(' argument_expression_list? ')'
    	/ '.' identifier
    	/ "->" identifier
    	/ "++"
    	/ "--"
	)*

#//(6.5.2)
argument_expression_list <-
	assignment_expression ( ',' assignment_expression )*

#//(6.5.3)
unary_expression <-
	postfix_expression
	/ "++" unary_expression
	/ "--" unary_expression
	/ unary_operator cast_expression
	/ "sizeof" unary_expression
	/ "sizeof" '(' type_name ')'
	/ "_Alignof" '(' type_name ')'

#//(6.5.3)
unary_operator <-
	[&*+~!-]
	#'&' / '*' / '+' / '-' / '~' / '!'

#//(6.5.4)
cast_expression <-
	unary_expression
	/ '(' type_name ')' cast_expression

####//(6.5.5)
###multiplicative_expression <-
###	cast_expression ( ('*' / '/' / '%') cast_expression )*
###
####//(6.5.6)
###additive_expression <-
###	multiplicative_expression ( ('+' / '-') multiplicative_expression )*
###
####//(6.5.7)
###shift_expression <-
###	additive_expression ( ("<<" / ">>")  additive_expression )*
###
####//(6.5.8)
###relational_expression <-
###	shift_expression ( ('<' / '>' / "<=" / ">=") shift_expression )*
###
####//(6.5.9)
###equality_expression <-
###	relational_expression ( ("==" / "!=") relational_expression )*
###
####//(6.5.10)
###AND_expression <-
###	equality_expression ( '&' equality_expression )*
###
####//(6.5.11)
###exclusive_OR_expression <-
###	AND_expression ( '^' AND_expression )*
###
####//(6.5.12)
###inclusive_OR_expression <-
###	exclusive_OR_expression ( '|' exclusive_OR_expression )*
###
####//(6.5.13)
###logical_AND_expression <-
###	inclusive_OR_expression ( "&&" inclusive_OR_expression )*
###
####//(6.5.14)
###logical_OR_expression <-
###	logical_AND_expression ( "||" logical_AND_expression )*

#//(6.5.15)
conditional_expression <-
	logical_OR_expression ( '?' expression ':' conditional_expression )*

#//(6.5.16)
assignment_expression <-
	 unary_expression assignment_operator assignment_expression
	/ conditional_expression

#//(6.5.16)
assignment_operator <-
	'=' / "*=" / "/=" / "%=" / "+=" / "-=" / "<<=" / ">>=" / "&=" / "^=" / "|="

#//(6.5.17)
expression <-
	assignment_expression ( ',' assignment_expression )*

#//(6.6)
constant_expression <-
	conditional_expression


logical_OR_expression <-
	INFIX_EXPRESSION(cast_expression, operator)

operator <-
	<
	  '||'
	/ '&&'

    / '|'
    / '^'
    / '&'

	/ '=='
	/ '!='

	/ '<='
	/ '<'
	/ '>='
	/ '>'

	/ '<<'
	/ '>>'

	/ '+'
	/ '-'

	/ '*'
	/ '/'
	/ '%'
	 >


# Declare order of precedence
INFIX_EXPRESSION(A, O) <-  A (O A)* {
    precedence
      L '||' # operators should be literal tokens
      L '&&'
      L '|'
      L '^'
      L '&'
      L '==' '!='
      L '<' '<=' '>=' '>'
      L '<<' '>>'
      L '+' '-'
      L '*' '/' '%'
}

#//A.2.2 Declarations
#//(6.7)
declaration <-
	declaration_specifiers init_declarator_list? ';'
	/ static_assert_declaration

#//(6.7)
declaration_specifiers <-
	storage_class_specifier declaration_specifiers?
	/ type_specifier declaration_specifiers?
	/ type_qualifier declaration_specifiers?
	/ function_specifier declaration_specifiers?
	/ alignment_specifier declaration_specifiers?

#//(6.7)
init_declarator_list <-
	init_declarator ( ',' init_declarator )*

#//(6.7)
init_declarator <-
	 declarator '=' initializer
	/ declarator

#//(6.7.1)
storage_class_specifier <-
	"typedef"
	/ "extern"
	/ "static"
	/ "_Thread_local"
	/ "auto"
	/ "register"

#//(6.7.2)
type_specifier <-
	"void"
	/ "char"
	/ "short"
	/ "int"
	/ "long"
	/ "float"
	/ "double"
	/ "signed"
	/ "unsigned"
	/ "_Bool"
	/ "_Complex"
	/ atomic_type_specifier
	/ struct_or_union_specifier ("∗" / identifier)
	/ enum_specifier
	/ typedef_name

#//(6.7.2.1)
struct_or_union_specifier <-
	struct_or_union identifier? '{' struct_declaration_list '}'
	/ struct_or_union identifier

#//(6.7.2.1)
struct_or_union <-
	"struct"
	/ "union"

#//(6.7.2.1)
struct_declaration_list <-
	struct_declaration+

#//(6.7.2.1)
struct_declaration <-
	specifier_qualifier_list struct_declarator_list? ';'
	/ static_assert_declaration

#//(6.7.2.1)
specifier_qualifier_list <-
	type_specifier specifier_qualifier_list?
	/ type_qualifier specifier_qualifier_list?
	/ alignment_specifier specifier_qualifier_list?

#//(6.7.2.1)
struct_declarator_list <-
	struct_declarator ( ',' struct_declarator )*

#//(6.7.2.1)
struct_declarator <-
	declarator
	/ declarator? ':' constant_expression

#//(6.7.2.2)
enum_specifier <-
	"enum" identifier? '{' enumerator_list '}'
	/ "enum" identifier? '{' enumerator_list ',' '}'
	/ "enum" identifier

#//(6.7.2.2)
enumerator_list <-
	enumerator ( ',' enumerator )*

#//(6.7.2.2)
enumerator <-
	enumeration_constant
	/ enumeration_constant '=' constant_expression

#//(6.7.2.4)
atomic_type_specifier <-
	"_Atomic" '(' type_name ')'

#//(6.7.3)
type_qualifier <-
	"const"
	/ "restrict"
	/ "volatile"
	/ "_Atomic"

#//(6.7.4)
function_specifier <-
	"inline"
	/ "_Noreturn"

#//(6.7.5)
alignment_specifier <-
	"_Alignas" '(' type_name ')'
	/ "_Alignas" '(' constant_expression ')'

#//(6.7.6)
declarator <-
	pointer? direct_declarator

#//(6.7.6)
direct_declarator <-
	(identifier / '(' declarator ')') (
    	  '[' type_qualifier_list? assignment_expression? ']'
    	/ '[' "static" type_qualifier_list? assignment_expression ']'
    	/ '[' type_qualifier_list "static" assignment_expression ']'
    	/ '[' type_qualifier_list? '*' ']'
    	/ '(' parameter_type_list ')'
    	/ '(' identifier_list? ')'
    	)*

#//(6.7.6)
pointer <-
	'*' type_qualifier_list?
	/ '*' type_qualifier_list? pointer

#//(6.7.6)
type_qualifier_list <-
	type_qualifier+

#//(6.7.6)
parameter_type_list <-
	parameter_list ( ',' "..." )?

#//(6.7.6)
parameter_list <-
	parameter_declaration ( ',' parameter_declaration )*

#//(6.7.6)
parameter_declaration <-
	declaration_specifiers declarator
	/ declaration_specifiers abstract_declarator?

#//(6.7.6)
identifier_list <-
	identifier ( ',' identifier )*

#//(6.7.7)
type_name <-
	specifier_qualifier_list abstract_declarator?

#//(6.7.7)
abstract_declarator <-
	pointer
	/ pointer? direct_abstract_declarator

#//(6.7.7)
direct_abstract_declarator <-
	'(' abstract_declarator ')' direct_abstract_declarator2*
	/ direct_abstract_declarator2+

direct_abstract_declarator2 <-
	  '[' type_qualifier_list? assignment_expression? ']'
	/ '[' "static" type_qualifier_list? assignment_expression ']'
	/ '[' type_qualifier_list "static" assignment_expression ']'
	/ '[' '*' ']'
	/ '(' parameter_type_list? ')'

#//(6.7.8)
typedef_name <-
	'$' identifier

#//(6.7.9)
initializer <-
	assignment_expression
	/ '{' initializer_list '}'
	/ '{' initializer_list ',' '}'

#//(6.7.9)
initializer_list <-
	designation? initializer ( ',' designation? initializer )*

#//(6.7.9)
designation <-
	designator_list '='

#//(6.7.9)
designator_list <-
	designator+

#//(6.7.9)
designator <-
	'[' constant_expression ']'
	/ '.' identifier

#//(6.7.10)
static_assert_declaration <-
	"_Static_assert" '(' constant_expression ',' string_literal ')' ';'
	/ "_Static_assert" '(' constant_expression ')' ';'

#//A.2.3 Statements
#//(6.8)
statement <-
	labeled_statement
	/ compound_statement
	/ expression_statement
	/ selection_statement
	/ iteration_statement
	/ jump_statement

#//(6.8.1)
labeled_statement <-
	identifier ':' statement
	/ "case" constant_expression ':' statement
	/ "default" ':' statement

#//(6.8.2)
compound_statement <-
	'{' block_item_list? '}'

#//(6.8.2)
block_item_list <-
	block_item+

#//(6.8.2)
block_item <-
	declaration
	/ statement

#//(6.8.3)
expression_statement <-
	expression? ';'

#//(6.8.4)
selection_statement <-
	 "if" '(' expression ')' statement "else" statement
	/ "if" '(' expression ')' statement
	/ "switch" '(' expression ')' statement

#//(6.8.5)
iteration_statement <-
	"while" '(' expression ')' statement
	/ "do" statement "while" '(' expression ')' ';'
	/ "for" '(' expression? ';' expression? ';' expression? ')' statement
	/ "for" '(' declaration expression? ';' expression? ')' statement

#//(6.8.6)
jump_statement <-
	"goto" identifier ';'
	/ "continue" ';'
	/ "break" ';'
	/ "return" expression? ';'

#//A.2.4 External definitions
#//(6.9)
translation_unit <-
	external_declaration+

#//(6.9)
external_declaration <-
	function_definition
	/ declaration

#//(6.9.1)
function_definition <-
	declaration_specifiers declarator declaration_list? compound_statement

#//(6.9.1)
declaration_list <-
	declaration+

#//A.3 Preprocessing directives
#//(6.10)
preprocessing_file <-
	group?

#//(6.10)
group <-
	group_part+

#//(6.10)
group_part <-
	if_section
	/ control_line
	/ text_line
	/ '#' non_directive

#//(6.10)
if_section <-
	if_group elif_groups? else_group? endif_line

#//(6.10)
if_group <-
	'#' "if" constant_expression new_line group?
	/ '#' "ifdef" identifier new_line group?
	/ '#' "ifndef" identifier new_line group?

#//(6.10)
elif_groups <-
	elif_group+

#//(6.10)
elif_group <-
	'#' "elif" constant_expression new_line group?

#//(6.10)
else_group <-
	'#' "else" new_line group?

#//(6.10)
endif_line <-
	'#' "endif" #new_line

#//(6.10)
control_line <-
	'#' "include" pp_tokens new_line
	/ '#' "define" identifier replacement_list #new_line
	/ '#' "define" identifier lparen identifier_list ',' "..." ')' replacement_list #new_line
	/ '#' "define" identifier lparen identifier_list? ')' replacement_list #new_line
	/ '#' "define" identifier lparen "..." ')' replacement_list #new_line
	/ '#' "undef" identifier #new_line
	/ '#' "line" pp_tokens #new_line
	/ '#' "error" pp_tokens? #new_line
	/ '#' "pragma" pp_tokens? #new_line
	/ '#' #new_line

#//(6.10)
text_line <-
	pp_tokens? new_line

#//(6.10)
non_directive <-
	pp_tokens new_line

#//(6.10)
lparen <-
	[(] !WS #"{ a ( character not immediately preceded by white_space }"

#//(6.10)
replacement_list <-
	pp_tokens?

#//(6.10)
pp_tokens <-
	preprocessing_token+

#//(6.10)
new_line <-
	'\n' '\r'? / '\r' '\n'? #"{ the new_line character }"

#//(6.10.6)
#on_off_switch <-
#	"ON" / "OFF" / "DEFAULT"

#//A.4 Floating-point subject sequence
#//A.4.1 NaN char sequence
#//(7.22.1.3)
#n_char_sequence <-
#	digit+
#	/ nondigit+

#//A.4.2 NaN wchar sequence
#//(7.29.4.1.1)
#n_wchar_sequence <-
#	digit+
#	/ nondigit+

COMMENT <- "//"[^\n]* / "/*" (!"*/" .)* "*/"
WS <- [ \t\r\n\f\v]
%whitespace <- (WS+ / COMMENT)*